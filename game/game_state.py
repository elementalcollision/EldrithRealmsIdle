import time
import json
import os
import zlib
import base64
import pygame
import random
import time
from game.constants import (RESOURCE_TYPES, RACES, BUILDINGS, RESEARCH, 
                           PRESTIGE_UPGRADES, ACHIEVEMENTS, BASE_INCOME_RATE, 
                           PRESTIGE_REQUIREMENT_BASE, PRESTIGE_SCALING, PRESTIGE_BONUS_BASE,
                           OFFLINE_PROGRESS_RATE, TIME_WARP_DURATION, TIME_WARP_COOLDOWN)

class GameState:
    def __init__(self):
        # Initialize resources
        self.resources = {resource: 0 for resource in RESOURCE_TYPES}
        self.resources["gold"] = 100  # Starting gold
        
        # Initialize races
        self.races = {}
        for race_id, race_data in RACES.items():
            # Initialize race abilities if present
            race_abilities = {}
            if "special_abilities" in race_data:
                for ability_id, ability_data in race_data["special_abilities"].items():
                    race_abilities[ability_id] = {
                        "unlocked": False,
                        "active": False
                    }
            
            # Initialize race skill tracking
            race_skills = {}
            for resource in RESOURCE_TYPES:
                race_skills[resource] = 0
                    
            self.races[race_id] = {
                "count": 0,
                "level": 1,
                "unlocked": race_data["unlock_level"] == 1,  # Only unlock starting races
                "abilities": race_abilities,
                "skills": race_skills  # Track resources generated by this race
            }
        
        # Initialize buildings
        self.buildings = {}
        for building_id, building_data in BUILDINGS.items():
            self.buildings[building_id] = {
                "count": 0,
                "level": 1,
                "unlocked": building_data["unlock_level"] <= 1  # Only unlock starting buildings
            }
            
        # Initialize research
        self.research = {}
        for research_id, research_data in RESEARCH.items():
            self.research[research_id] = {
                "level": 0,
                "unlocked": research_data["unlock_level"] <= 1
            }
            
        # Initialize prestige upgrades
        self.prestige_upgrades = {}
        for upgrade_id, upgrade_data in PRESTIGE_UPGRADES.items():
            self.prestige_upgrades[upgrade_id] = {
                "level": 0
            }
            
        # Initialize achievements
        self.achievements = {
            "resource_milestones": {milestone["id"]: False for milestone in ACHIEVEMENTS["resource_milestones"]},
            "race_milestones": {milestone["id"]: False for milestone in ACHIEVEMENTS["race_milestones"]},
            "race_skill_milestones": {milestone["id"]: False for milestone in ACHIEVEMENTS["race_skill_milestones"]},
            "building_milestones": {milestone["id"]: False for milestone in ACHIEVEMENTS["building_milestones"]},
            "prestige_milestones": {milestone["id"]: False for milestone in ACHIEVEMENTS["prestige_milestones"]},
            "time_milestones": {milestone["id"]: False for milestone in ACHIEVEMENTS["time_milestones"]}
        }
        
        # Game progression
        self.player_level = 1
        self.total_earnings = 0
        self.prestige_count = 0
        self.prestige_points = 0
        self.total_prestige_points = 0
        self.permanent_multipliers = {"all": 1.0}
        
        # Time tracking
        self.last_save_time = time.time()
        self.total_play_time = 0
        self.time_warp_active = False
        self.time_warp_end_time = 0
        self.time_warp_cooldown_end = 0
        
        # Notifications
        self.notifications = []
    
    def update(self, elapsed_time):
        """Update game state based on elapsed time"""
        # Apply time warp if active
        if self.time_warp_active:
            current_time = time.time()
            if current_time >= self.time_warp_end_time:
                self.time_warp_active = False
                self.add_notification("Time Warp has ended!")
            else:
                # Apply time warp multiplier from prestige upgrades
                time_warp_multiplier = self.get_time_warp_multiplier()
                elapsed_time *= time_warp_multiplier
        
        # Update total play time
        self.total_play_time += elapsed_time
        
        # Calculate resource generation for the elapsed time
        self.generate_resources(elapsed_time)
        
        # Check for unlocks based on progression
        self.check_unlocks()
        
        # Check for achievements
        self.check_achievements()
    
    def generate_resources(self, elapsed_time):
        """Generate resources based on owned races, buildings, and elapsed time"""
        # Check for special resource generation from race abilities
        self.apply_special_resource_generation(elapsed_time)
        
        # Process normal resource generation
        for resource in RESOURCE_TYPES:
            # Skip prestige points - those are only earned through prestige
            if resource == "prestige_points":
                continue
                
            generation_rate = self.calculate_resource_generation_rate(resource)
            amount_generated = generation_rate * elapsed_time
            
            # Apply global multipliers from research, achievements, etc.
            global_multiplier = self.calculate_global_multiplier(resource)
            amount_generated *= global_multiplier
            
            # Apply time-based modifiers from race abilities
            time_modifier = self.get_time_based_modifier(resource)
            amount_generated *= time_modifier
            
            # Apply random chance modifiers from race abilities
            if self.check_production_doubling_chance():
                amount_generated *= 2
                
            self.resources[resource] += amount_generated
            
            # Track total earnings for progression
            if resource == "gold":
                self.total_earnings += amount_generated
            
            # Track race-specific resource generation for skill achievements
            self.track_race_resource_generation(resource, amount_generated)
                
        # Generate passive prestige points if applicable
        self.generate_passive_prestige_points(elapsed_time)
    
    def calculate_resource_generation_rate(self, resource):
        """Calculate generation rate for a specific resource"""
        base_rate = 0
        
        # Add passive generation from race abilities if applicable
        passive_rate = self.get_passive_generation_rate(resource)
        base_rate += passive_rate
        
        # Add contribution from each race
        race_bonus_multiplier = self.get_race_bonus_multiplier()
        for race_id, race_data in self.races.items():
            if race_data["unlocked"] and race_data["count"] > 0:
                race_info = RACES[race_id]
                
                # Base contribution
                race_contribution = BASE_INCOME_RATE * race_data["count"] * race_data["level"]
                
                # Apply race-specific bonuses
                if "resource_bonuses" in race_info and resource in race_info["resource_bonuses"]:
                    bonus = race_info["resource_bonuses"][resource] * race_bonus_multiplier
                    race_contribution *= bonus
                
                # Apply race-specific ability bonuses
                ability_bonus = self.get_race_specific_ability_bonus(race_id, resource)
                race_contribution *= ability_bonus
                
                # Apply race-specific skill achievement bonuses
                skill_multiplier = self.get_race_skill_multiplier(race_id, resource)
                race_contribution *= skill_multiplier
                
                base_rate += race_contribution
        
        # Add contribution from buildings
        for building_id, building_data in self.buildings.items():
            if building_data["unlocked"] and building_data["count"] > 0:
                building_info = BUILDINGS[building_id]
                
                # Check if building produces this resource
                if "resource_production" in building_info and resource in building_info["resource_production"]:
                    # Calculate base production
                    production_rate = building_info["resource_production"][resource]
                    
                    # Apply level scaling
                    level_multiplier = building_info["level_scaling"] ** (building_data["level"] - 1)
                    
                    # Calculate total contribution
                    building_contribution = production_rate * building_data["count"] * level_multiplier
                    base_rate += building_contribution
        
        # Add flat bonuses from research
        research_flat_bonus = self.get_research_flat_bonus(resource)
        base_rate += research_flat_bonus
        
        return base_rate
    
    def calculate_global_multiplier(self, resource):
        """Calculate global multiplier for a specific resource"""
        multiplier = 1.0
        
        # Apply building global multipliers
        for building_id, building_data in self.buildings.items():
            if building_data["unlocked"] and building_data["count"] > 0:
                building_info = BUILDINGS[building_id]
                
                # Check if building has global multipliers
                if "global_multipliers" in building_info:
                    # Apply resource-specific multiplier
                    if resource in building_info["global_multipliers"]:
                        # Calculate multiplier with level scaling
                        level_bonus = (building_info["level_scaling"] - 1) * (building_data["level"] - 1)
                        building_multiplier = building_info["global_multipliers"][resource] + level_bonus
                        multiplier *= building_multiplier
                    
                    # Apply all-resource multiplier
                    if "all" in building_info["global_multipliers"]:
                        level_bonus = (building_info["level_scaling"] - 1) * (building_data["level"] - 1)
                        building_multiplier = building_info["global_multipliers"]["all"] + level_bonus
                        multiplier *= building_multiplier
        
        # Apply race ability multipliers
        race_ability_multiplier = self.get_race_ability_multiplier(resource)
        multiplier *= race_ability_multiplier
        
        # Apply resource-specific multipliers from race skill achievements
        for milestone in ACHIEVEMENTS["race_skill_milestones"]:
            milestone_id = milestone["id"]
            
            if self.achievements["race_skill_milestones"][milestone_id]:
                reward = milestone["reward"]
                
                # Apply resource-specific multiplier
                if f"{resource}_multiplier" in reward:
                    multiplier *= reward[f"{resource}_multiplier"]
                
                # Apply all-resources multiplier
                if "all_resources_multiplier" in reward:
                    multiplier *= reward["all_resources_multiplier"]
        
        # Apply research multipliers
        resource_multiplier = self.get_research_multiplier(resource)
        multiplier *= resource_multiplier
        
        # Apply achievement bonuses
        achievement_multiplier = self.get_achievement_multiplier(resource)
        multiplier *= achievement_multiplier
        
        # Apply race ability multipliers
        race_ability_multiplier = self.get_race_ability_multiplier(resource)
        multiplier *= race_ability_multiplier
        
        # Apply prestige bonuses
        prestige_multiplier = 1.0 + (self.prestige_count * PRESTIGE_BONUS_BASE)
        multiplier *= prestige_multiplier
        
        # Apply permanent multipliers from prestige upgrades
        if resource in self.permanent_multipliers:
            multiplier *= self.permanent_multipliers[resource]
        if "all" in self.permanent_multipliers:
            multiplier *= self.permanent_multipliers["all"]
        
        return multiplier
    
    def can_afford(self, costs):
        """Check if player can afford the given costs"""
        for resource, amount in costs.items():
            if self.resources.get(resource, 0) < amount:
                return False
        return True
    
    def spend_resources(self, costs):
        """Spend resources if player can afford them"""
        if not self.can_afford(costs):
            return False
        
        for resource, amount in costs.items():
            self.resources[resource] -= amount
        
        return True
    
    def add_race(self, race_id, count=1):
        """Add count of a specific race"""
        if race_id in self.races and self.races[race_id]["unlocked"]:
            self.races[race_id]["count"] += count
            return True
        return False
    
    def upgrade_race(self, race_id):
        """Upgrade a specific race"""
        if race_id in self.races and self.races[race_id]["unlocked"] and self.races[race_id]["count"] > 0:
            self.races[race_id]["level"] += 1
            return True
        return False
    
    def add_building(self, building_id, count=1):
        """Add count of a specific building"""
        if building_id in self.buildings and self.buildings[building_id]["unlocked"]:
            self.buildings[building_id]["count"] += count
            
            # Check for first building achievement
            if count > 0 and self.buildings[building_id]["count"] == count:
                self.check_building_achievements()
                
            return True
        return False
    
    def upgrade_building(self, building_id):
        """Upgrade a specific building"""
        if building_id in self.buildings and self.buildings[building_id]["unlocked"] and self.buildings[building_id]["count"] > 0:
            # Check if at max level
            building_info = BUILDINGS[building_id]
            if self.buildings[building_id]["level"] >= building_info["max_level"]:
                return False
                
            self.buildings[building_id]["level"] += 1
            
            # Check for building level achievements
            self.check_building_achievements()
            
            return True
        return False
    
    def research_technology(self, research_id):
        """Research or upgrade a technology"""
        if research_id in self.research and self.research[research_id]["unlocked"]:
            # Check if at max level
            research_info = RESEARCH[research_id]
            if self.research[research_id]["level"] >= research_info["max_level"]:
                return False
                
            self.research[research_id]["level"] += 1
            return True
        return False
    
    def purchase_prestige_upgrade(self, upgrade_id):
        """Purchase or upgrade a prestige upgrade"""
        if upgrade_id in self.prestige_upgrades:
            # Check if at max level
            upgrade_info = PRESTIGE_UPGRADES[upgrade_id]
            if self.prestige_upgrades[upgrade_id]["level"] >= upgrade_info["max_level"]:
                return False
                
            self.prestige_upgrades[upgrade_id]["level"] += 1
            
            # Apply permanent effects if applicable
            if upgrade_id == "cosmic_insight":
                # Update permanent multiplier
                effect = upgrade_info["effect"]["permanent_multiplier"]
                if "all" not in self.permanent_multipliers:
                    self.permanent_multipliers["all"] = 1.0
                self.permanent_multipliers["all"] *= effect
                
            return True
        return False
    
    def check_unlocks(self):
        """Check for new unlocks based on player progression"""
        # Update player level based on total earnings
        new_level = 1 + int(self.total_earnings / 1000)  # Simple level formula
        level_changed = new_level > self.player_level
        
        if level_changed:
            self.player_level = new_level
            self.add_notification(f"Level up! You are now level {self.player_level}")
            
            # Check for race unlocks
            for race_id, race_data in RACES.items():
                if not self.races[race_id]["unlocked"]:
                    # Check level requirement
                    level_ok = race_data["unlock_level"] <= self.player_level
                    
                    # Check prestige requirement if applicable
                    prestige_ok = True
                    if "requires_prestige" in race_data:
                        prestige_ok = self.prestige_count >= race_data["requires_prestige"]
                    
                    if level_ok and prestige_ok:
                        self.races[race_id]["unlocked"] = True
                        self.add_notification(f"New race unlocked: {race_data['name']}!")
        
        # Check for race ability unlocks
        self.check_race_ability_unlocks()
        
        # Check for building unlocks
        for building_id, building_data in BUILDINGS.items():
            if not self.buildings[building_id]["unlocked"]:
                # Check level requirement
                level_ok = building_data["unlock_level"] <= self.player_level
                
                # Check prestige requirement if applicable
                prestige_ok = True
                if "requires_prestige" in building_data:
                    prestige_ok = self.prestige_count >= building_data["requires_prestige"]
                
                if level_ok and prestige_ok:
                    self.buildings[building_id]["unlocked"] = True
                    self.add_notification(f"New building unlocked: {building_data['name']}!")
            
            # Check for research unlocks
            for research_id, research_data in RESEARCH.items():
                if not self.research[research_id]["unlocked"]:
                    # Check level requirement
                    level_ok = research_data["unlock_level"] <= self.player_level
                    
                    # Check prestige requirement if applicable
                    prestige_ok = True
                    if "requires_prestige" in research_data:
                        prestige_ok = self.prestige_count >= research_data["requires_prestige"]
                    
                    if level_ok and prestige_ok:
                        self.research[research_id]["unlocked"] = True
                        self.add_notification(f"New research unlocked: {research_data['name']}!")
    
    def get_race_purchase_cost(self, race_id, count=1):
        """Calculate the cost to purchase a race"""
        if race_id not in RACES:
            return {}
            
        race_info = RACES[race_id]
        race_data = self.races[race_id]
        
        base_cost = race_info["base_cost"]
        current_count = race_data["count"]
        
        # For bulk purchases, calculate the cumulative cost
        if count == 1:
            # Simple case: buying just one
            cost_multiplier = 1.0 + (0.15 * current_count)
            gold_cost = base_cost * cost_multiplier
            return {"gold": gold_cost}
        else:
            # Bulk purchase: sum up costs for each increment
            total_gold_cost = 0
            for i in range(count):
                cost_multiplier = 1.0 + (0.15 * (current_count + i))
                total_gold_cost += base_cost * cost_multiplier
            return {"gold": total_gold_cost}
    
    def get_race_upgrade_cost(self, race_id, count=1):
        """Calculate the cost to upgrade a race"""
        if race_id not in RACES:
            return {}
            
        race_info = RACES[race_id]
        race_data = self.races[race_id]
        
        base_cost = race_info["base_cost"] * 5  # Upgrades are more expensive
        current_level = race_data["level"]
        
        # For bulk upgrades, calculate the cumulative cost
        if count == 1:
            # Simple case: just one upgrade
            cost_multiplier = 2.0 ** (current_level - 1)
            gold_cost = base_cost * cost_multiplier
            return {"gold": gold_cost}
        else:
            # Bulk upgrade: sum up costs for each level
            total_gold_cost = 0
            for i in range(count):
                level_cost_multiplier = 2.0 ** (current_level + i - 1)
                total_gold_cost += base_cost * level_cost_multiplier
            return {"gold": total_gold_cost}
    
    def get_building_purchase_cost(self, building_id, count=1):
        """Calculate the cost to purchase a building"""
        if building_id not in BUILDINGS:
            return {}
            
        building_info = BUILDINGS[building_id]
        building_data = self.buildings[building_id]
        
        base_costs = building_info["base_cost"]
        current_count = building_data["count"]
        
        # For bulk purchases, calculate the cumulative cost
        costs = {}
        
        if count == 1:
            # Simple case: buying just one
            cost_multiplier = 1.0 + (0.2 * current_count)
            
            # Apply any cost reduction from achievements
            if self.has_achievement("first_building"):
                cost_multiplier *= 0.95  # 5% cost reduction
            
            # Calculate costs for each resource
            for resource, amount in base_costs.items():
                costs[resource] = amount * cost_multiplier
        else:
            # Bulk purchase: sum up costs for each increment
            for resource, base_amount in base_costs.items():
                total_cost = 0
                for i in range(count):
                    cost_multiplier = 1.0 + (0.2 * (current_count + i))
                    
                    # Apply any cost reduction from achievements
                    if self.has_achievement("first_building"):
                        cost_multiplier *= 0.95  # 5% cost reduction
                    
                    total_cost += base_amount * cost_multiplier
                costs[resource] = total_cost
            
        return costs
    
    def get_building_upgrade_cost(self, building_id, count=1):
        """Calculate the cost to upgrade a building"""
        if building_id not in BUILDINGS:
            return {}
            
        building_info = BUILDINGS[building_id]
        building_data = self.buildings[building_id]
        
        base_costs = building_info["base_cost"]
        current_level = building_data["level"]
        
        # For bulk upgrades, calculate the cumulative cost
        costs = {}
        
        if count == 1:
            # Simple case: just one upgrade
            cost_multiplier = 2.0 ** (current_level - 1)
            
            # Apply any cost reduction from achievements
            if self.has_achievement("first_building"):
                cost_multiplier *= 0.95  # 5% cost reduction
            
            # Calculate costs for each resource
            for resource, amount in base_costs.items():
                costs[resource] = amount * cost_multiplier * 2  # Upgrades cost more than purchases
        else:
            # Bulk upgrade: sum up costs for each level
            for resource, base_amount in base_costs.items():
                total_cost = 0
                for i in range(count):
                    level_cost_multiplier = 2.0 ** (current_level + i - 1)
                    
                    # Apply any cost reduction from achievements
                    if self.has_achievement("first_building"):
                        level_cost_multiplier *= 0.95  # 5% cost reduction
                    
                    total_cost += base_amount * level_cost_multiplier * 2
                costs[resource] = total_cost
            
        return costs
    
    def get_research_cost(self, research_id, count=1):
        """Calculate the cost to research or upgrade a technology"""
        if research_id not in RESEARCH:
            return {}
            
        research_info = RESEARCH[research_id]
        research_data = self.research[research_id]
        
        base_costs = research_info["cost"]
        current_level = research_data["level"]
        
        # For bulk research, we need to calculate the cumulative cost
        # of multiple upgrades with increasing costs
        costs = {}
        
        if count == 1:
            # Simple case: just one level
            cost_multiplier = research_info["cost_scaling"] ** current_level
            
            # Calculate costs for each resource
            for resource, amount in base_costs.items():
                costs[resource] = amount * cost_multiplier
        else:
            # Bulk research: sum up costs for each level
            for resource, base_amount in base_costs.items():
                total_cost = 0
                for i in range(count):
                    level_cost_multiplier = research_info["cost_scaling"] ** (current_level + i)
                    total_cost += base_amount * level_cost_multiplier
                costs[resource] = total_cost
            
        return costs
    
    def get_prestige_upgrade_cost(self, upgrade_id, count=1):
        """Calculate the cost for a prestige upgrade"""
        if upgrade_id not in PRESTIGE_UPGRADES:
            return {}
            
        upgrade_info = PRESTIGE_UPGRADES[upgrade_id]
        upgrade_data = self.prestige_upgrades[upgrade_id]
        
        base_costs = upgrade_info["cost"]
        current_level = upgrade_data["level"]
        
        # Calculate costs for each resource
        costs = {}
        
        if count == 1:
            # Simple case: just one upgrade
            cost_multiplier = 1.0
            if current_level > 0 and "cost_scaling" in upgrade_info:
                cost_multiplier = upgrade_info["cost_scaling"] ** current_level
            
            # Calculate costs for each resource
            for resource, amount in base_costs.items():
                costs[resource] = amount * cost_multiplier
        else:
            # Bulk upgrade: sum up costs for each level
            for resource, base_amount in base_costs.items():
                total_cost = 0
                for i in range(count):
                    level_cost_multiplier = 1.0
                    if (current_level + i) > 0 and "cost_scaling" in upgrade_info:
                        level_cost_multiplier = upgrade_info["cost_scaling"] ** (current_level + i)
                    
                    total_cost += base_amount * level_cost_multiplier
                costs[resource] = total_cost
            
        return costs
    
    # Achievement and prestige systems
    def check_achievements(self):
        """Check for achievement completion"""
        self.check_resource_achievements()
        self.check_race_achievements()
        self.check_building_achievements()
        self.check_prestige_achievements()
        self.check_time_achievements()
        self.check_race_skill_achievements()
    
    def check_resource_achievements(self):
        """Check resource-based achievements"""
        for milestone in ACHIEVEMENTS["resource_milestones"]:
            milestone_id = milestone["id"]
            
            # Skip if already achieved
            if self.achievements["resource_milestones"][milestone_id]:
                continue
                
            # Check requirement
            requirement = milestone["requirement"]
            for resource, amount in requirement.items():
                if self.resources.get(resource, 0) >= amount:
                    self.achievements["resource_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
    
    def check_race_achievements(self):
        """Check race-based achievements"""
        for milestone in ACHIEVEMENTS["race_milestones"]:
            milestone_id = milestone["id"]
            
            # Skip if already achieved
            if self.achievements["race_milestones"][milestone_id]:
                continue
                
            # Check requirement
            requirement = milestone["requirement"]
            
            # Check for specific race count
            if "race" in requirement and "count" in requirement:
                race_id = requirement["race"]
                count = requirement["count"]
                
                if race_id in self.races and self.races[race_id]["count"] >= count:
                    self.achievements["race_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
            
            # Check for all races at a certain count
            elif "all_races" in requirement:
                min_count = requirement["all_races"]
                all_races_meet_requirement = True
                
                for race_id, race_data in self.races.items():
                    if race_data["unlocked"] and race_data["count"] < min_count:
                        all_races_meet_requirement = False
                        break
                
                if all_races_meet_requirement:
                    self.achievements["race_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
    
    def check_building_achievements(self):
        """Check building-based achievements"""
        for milestone in ACHIEVEMENTS["building_milestones"]:
            milestone_id = milestone["id"]
            
            # Skip if already achieved
            if self.achievements["building_milestones"][milestone_id]:
                continue
                
            # Check requirement
            requirement = milestone["requirement"]
            
            # Check for any building
            if "any_building" in requirement:
                count = requirement["any_building"]
                any_building_meets_requirement = False
                
                for building_id, building_data in self.buildings.items():
                    if building_data["count"] >= count:
                        any_building_meets_requirement = True
                        break
                
                if any_building_meets_requirement:
                    self.achievements["building_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
            
            # Check for any building level
            elif "any_building_level" in requirement:
                level = requirement["any_building_level"]
                any_building_meets_level = False
                
                for building_id, building_data in self.buildings.items():
                    if building_data["count"] > 0 and building_data["level"] >= level:
                        any_building_meets_level = True
                        break
                
                if any_building_meets_level:
                    self.achievements["building_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
            
            # Check for all buildings at a certain level
            elif "all_buildings" in requirement:
                min_level = requirement["all_buildings"]
                all_buildings_meet_requirement = True
                
                for building_id, building_data in self.buildings.items():
                    # Only consider unlocked buildings with at least one built
                    if building_data["unlocked"] and building_data["count"] > 0:
                        if building_data["level"] < min_level:
                            all_buildings_meet_requirement = False
                            break
                
                if all_buildings_meet_requirement:
                    self.achievements["building_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
            
            # Check for specific building
            elif "building" in requirement and "count" in requirement:
                building_id = requirement["building"]
                count = requirement["count"]
                
                if building_id in self.buildings and self.buildings[building_id]["count"] >= count:
                    self.achievements["building_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
    
    def check_prestige_achievements(self):
        """Check prestige-based achievements"""
        for milestone in ACHIEVEMENTS["prestige_milestones"]:
            milestone_id = milestone["id"]
            
            # Skip if already achieved
            if self.achievements["prestige_milestones"][milestone_id]:
                continue
                
            # Check requirement
            requirement = milestone["requirement"]
            
            if "prestige_count" in requirement:
                count = requirement["prestige_count"]
                
                if self.prestige_count >= count:
                    self.achievements["prestige_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
    
    def check_time_achievements(self):
        """Check time-based achievements"""
        for milestone in ACHIEVEMENTS["time_milestones"]:
            milestone_id = milestone["id"]
            
            # Skip if already achieved
            if self.achievements["time_milestones"][milestone_id]:
                continue
                
            # Check requirement
            requirement = milestone["requirement"]
            
            if "play_time" in requirement:
                seconds = requirement["play_time"]
                
                if self.total_play_time >= seconds:
                    self.achievements["time_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
    
    def track_race_resource_generation(self, resource, amount):
        """Track resources generated by each race for skill achievements"""
        # Calculate contribution from each race for this resource
        race_contributions = {}
        total_contribution = 0
        
        # Calculate base contribution from each race
        for race_id, race_data in self.races.items():
            if race_data["unlocked"] and race_data["count"] > 0:
                race_info = RACES[race_id]
                
                # Base contribution
                race_contribution = BASE_INCOME_RATE * race_data["count"] * race_data["level"]
                
                # Apply race-specific bonuses
                if "resource_bonuses" in race_info and resource in race_info["resource_bonuses"]:
                    bonus = race_info["resource_bonuses"][resource] * self.get_race_bonus_multiplier()
                    race_contribution *= bonus
                
                # Apply race-specific ability bonuses
                ability_bonus = self.get_race_specific_ability_bonus(race_id, resource)
                race_contribution *= ability_bonus
                
                race_contributions[race_id] = race_contribution
                total_contribution += race_contribution
        
        # If no races are contributing, return
        if total_contribution <= 0:
            return
        
        # Distribute the generated amount proportionally to each race's contribution
        for race_id, contribution in race_contributions.items():
            # Calculate proportion of total contribution
            proportion = contribution / total_contribution
            
            # Add to race's skill tracking
            race_amount = amount * proportion
            self.races[race_id]["skills"][resource] += race_amount
    
    def check_race_skill_achievements(self):
        """Check race skill-based achievements"""
        for milestone in ACHIEVEMENTS["race_skill_milestones"]:
            milestone_id = milestone["id"]
            
            # Skip if already achieved
            if self.achievements["race_skill_milestones"][milestone_id]:
                continue
                
            # Check requirement
            requirement = milestone["requirement"]
            
            # Check for race-specific resource generation
            if "race_skill" in requirement and "resource" in requirement and "amount" in requirement:
                race_id = requirement["race_skill"]
                resource = requirement["resource"]
                amount = requirement["amount"]
                
                # Check if race exists and is unlocked
                if race_id not in self.races or not self.races[race_id]["unlocked"]:
                    continue
                
                # Check player level requirement if present
                if "player_level" in requirement and self.player_level < requirement["player_level"]:
                    continue
                    
                # Check prestige level requirement if present
                if "prestige_level" in requirement and self.prestige_count < requirement["prestige_level"]:
                    continue
                
                # Check if race has generated enough of the resource
                if self.races[race_id]["skills"][resource] >= amount:
                    self.achievements["race_skill_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
            
            # Check for race generating all resources
            elif "race_skill" in requirement and "all_resources" in requirement:
                race_id = requirement["race_skill"]
                min_amount = requirement["all_resources"]
                
                # Check if race exists and is unlocked
                if race_id not in self.races or not self.races[race_id]["unlocked"]:
                    continue
                
                # Check player level requirement if present
                if "player_level" in requirement and self.player_level < requirement["player_level"]:
                    continue
                    
                # Check prestige level requirement if present
                if "prestige_level" in requirement and self.prestige_count < requirement["prestige_level"]:
                    continue
                
                # Check if race has generated enough of all resources
                all_resources_meet_requirement = True
                for resource in RESOURCE_TYPES:
                    if resource == "prestige_points":
                        continue  # Skip prestige points
                    
                    if self.races[race_id]["skills"][resource] < min_amount:
                        all_resources_meet_requirement = False
                        break
                
                if all_resources_meet_requirement:
                    self.achievements["race_skill_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
            
            # Check for time-based skill achievements
            elif "player_level" in requirement and "max_play_time" in requirement:
                player_level = requirement["player_level"]
                max_play_time = requirement["max_play_time"]
                
                if self.player_level >= player_level and self.total_play_time <= max_play_time:
                    self.achievements["race_skill_milestones"][milestone_id] = True
                    self.add_notification(f"Achievement unlocked: {milestone['name']}!")
    
    def get_race_skill_multiplier(self, race_id, resource):
        """Get multiplier for a specific race and resource from skill achievements"""
        multiplier = 1.0
        
        for milestone in ACHIEVEMENTS["race_skill_milestones"]:
            milestone_id = milestone["id"]
            
            if not self.achievements["race_skill_milestones"][milestone_id]:
                continue
                
            reward = milestone["reward"]
            requirement = milestone["requirement"]
            
            # Check if this achievement is for the specified race
            if "race_skill" in requirement and requirement["race_skill"] == race_id:
                # Apply race-specific resource bonus
                race_bonus_key = f"{race_id}_{resource}_bonus"
                if race_bonus_key in reward:
                    multiplier *= reward[race_bonus_key]
                
                # Apply general race bonus
                race_efficiency_key = f"{race_id}_efficiency"
                if race_efficiency_key in reward:
                    multiplier *= reward[race_efficiency_key]
        
        return multiplier
    
    def has_achievement(self, achievement_id):
        """Check if an achievement has been unlocked"""
        for category in self.achievements.values():
            if achievement_id in category and category[achievement_id]:
                return True
        return False
    
    def get_achievement_multiplier(self, resource):
        """Get production multiplier from achievements"""
        multiplier = 1.0
        
        # Check resource-specific multipliers
        for milestone in ACHIEVEMENTS["resource_milestones"]:
            milestone_id = milestone["id"]
            
            if self.achievements["resource_milestones"][milestone_id]:
                reward = milestone["reward"]
                
                # Apply resource-specific multiplier
                if f"{resource}_multiplier" in reward:
                    multiplier *= reward[f"{resource}_multiplier"]
        
        # Check global production multipliers
        for category in ACHIEVEMENTS.values():
            for milestone in category:
                if isinstance(milestone, dict) and "id" in milestone and "reward" in milestone:
                    milestone_id = milestone["id"]
                    category_name = next((cat for cat, milestones in ACHIEVEMENTS.items() 
                                       if milestone in milestones), None)
                    
                    if category_name and milestone_id in self.achievements[category_name] \
                       and self.achievements[category_name][milestone_id]:
                        reward = milestone["reward"]
                        
                        # Apply global production multiplier
                        if "all_production" in reward:
                            multiplier *= reward["all_production"]
        
        return multiplier
    
    def get_race_bonus_multiplier(self):
        """Get race bonus multiplier from research"""
        multiplier = 1.0
        
        # Check for racial harmony research
        if "racial_harmony" in self.research and self.research["racial_harmony"]["unlocked"]:
            level = self.research["racial_harmony"]["level"]
            if level > 0:
                research_info = RESEARCH["racial_harmony"]
                base_effect = research_info["effect"]["race_bonus_multiplier"]
                effect_scaling = research_info["effect_scaling"]
                
                # Calculate total effect based on level
                effect = 1.0 + ((base_effect - 1.0) * level * effect_scaling)
                multiplier *= effect
        
        # Check for race-specific achievement bonuses
        for milestone in ACHIEVEMENTS["race_milestones"]:
            milestone_id = milestone["id"]
            
            if self.achievements["race_milestones"][milestone_id]:
                reward = milestone["reward"]
                
                # Apply race efficiency bonuses
                if "all_race_efficiency" in reward:
                    multiplier *= reward["all_race_efficiency"]
        
        # Check for race skill achievement bonuses
        for milestone in ACHIEVEMENTS["race_skill_milestones"]:
            milestone_id = milestone["id"]
            
            if self.achievements["race_skill_milestones"][milestone_id]:
                reward = milestone["reward"]
                
                # Apply race efficiency bonuses
                if "all_race_efficiency" in reward:
                    multiplier *= reward["all_race_efficiency"]
        
        return multiplier
    
    def get_research_multiplier(self, resource):
        """Get resource multiplier from research"""
        multiplier = 1.0
        
        # Check all research for resource multipliers
        for research_id, research_data in self.research.items():
            if research_data["unlocked"] and research_data["level"] > 0:
                research_info = RESEARCH[research_id]
                
                # Check for resource multiplier effect
                if "effect" in research_info and "resource_multiplier" in research_info["effect"]:
                    resource_multipliers = research_info["effect"]["resource_multiplier"]
                    
                    # Apply resource-specific multiplier
                    if resource in resource_multipliers:
                        base_effect = resource_multipliers[resource]
                        effect_scaling = research_info["effect_scaling"]
                        level = research_data["level"]
                        
                        # Calculate total effect based on level
                        effect = 1.0 + ((base_effect - 1.0) * level * effect_scaling)
                        multiplier *= effect
                
                # Check for global multiplier effect
                if "effect" in research_info and "global_multiplier" in research_info["effect"]:
                    base_effect = research_info["effect"]["global_multiplier"]
                    effect_scaling = research_info["effect_scaling"]
                    level = research_data["level"]
                    
                    # Calculate total effect based on level
                    effect = 1.0 + ((base_effect - 1.0) * level * effect_scaling)
                    multiplier *= effect
        
        return multiplier
    
    def get_research_flat_bonus(self, resource):
        """Get flat resource generation bonus from research"""
        bonus = 0.0
        
        # Check for reality manipulation research (adds flat resource generation)
        if "reality_manipulation" in self.research and self.research["reality_manipulation"]["unlocked"]:
            level = self.research["reality_manipulation"]["level"]
            if level > 0:
                research_info = RESEARCH["reality_manipulation"]
                base_effect = research_info["effect"]["idle_resource_generation"]
                effect_scaling = research_info["effect_scaling"]
                
                # Calculate total effect based on level
                bonus += base_effect * (effect_scaling ** (level - 1))
        
        return bonus
    
    def get_time_warp_multiplier(self):
        """Get time warp multiplier from prestige upgrades"""
        if "time_warp" in self.prestige_upgrades:
            level = self.prestige_upgrades["time_warp"]["level"]
            if level > 0:
                upgrade_info = PRESTIGE_UPGRADES["time_warp"]
                base_effect = upgrade_info["effect"]["time_warp_multiplier"]
                effect_scaling = upgrade_info["effect_scaling"]
                
                # Calculate total effect based on level
                return base_effect * (effect_scaling ** (level - 1))
        
        return 2.0  # Default multiplier if no upgrade
    
    def activate_time_warp(self):
        """Activate time warp if available"""
        current_time = time.time()
        
        # Check if time warp is on cooldown
        if current_time < self.time_warp_cooldown_end:
            cooldown_remaining = int(self.time_warp_cooldown_end - current_time)
            self.add_notification(f"Time Warp is on cooldown. Available in {cooldown_remaining} seconds.")
            return False
        
        # Check if time warp upgrade is purchased
        if "time_warp" not in self.prestige_upgrades or self.prestige_upgrades["time_warp"]["level"] == 0:
            self.add_notification("Time Warp ability not unlocked. Purchase it from the Prestige Upgrades.")
            return False
        
        # Activate time warp
        self.time_warp_active = True
        self.time_warp_end_time = current_time + TIME_WARP_DURATION
        self.time_warp_cooldown_end = current_time + TIME_WARP_COOLDOWN
        
        multiplier = self.get_time_warp_multiplier()
        self.add_notification(f"Time Warp activated! Production increased by {multiplier}x for 1 hour.")
        return True
    
    def perform_prestige(self):
        """Perform a prestige reset and earn prestige points"""
        # Calculate prestige points to earn
        points_earned = self.calculate_prestige_points()
        
        if points_earned <= 0:
            self.add_notification("Not enough progress to earn prestige points. Keep playing!")
            return False
        
        # Store values that persist through prestige
        old_prestige_count = self.prestige_count
        old_total_prestige_points = self.total_prestige_points
        old_prestige_upgrades = self.prestige_upgrades.copy()
        old_permanent_multipliers = self.permanent_multipliers.copy()
        old_achievements = self.achievements.copy()
        old_total_play_time = self.total_play_time
        
        # Calculate resource retention from prestige upgrades
        retained_resources = {}
        retained_knowledge = 0
        
        if "resource_memory" in self.prestige_upgrades and self.prestige_upgrades["resource_memory"]["level"] > 0:
            level = self.prestige_upgrades["resource_memory"]["level"]
            upgrade_info = PRESTIGE_UPGRADES["resource_memory"]
            retention_rate = upgrade_info["effect"]["resource_retention"] * level
            
            # Retain basic resources
            basic_resources = ["gold", "wood", "stone", "food", "mana"]
            for resource in basic_resources:
                retained_resources[resource] = self.resources.get(resource, 0) * retention_rate
        
        if "eternal_knowledge" in self.prestige_upgrades and self.prestige_upgrades["eternal_knowledge"]["level"] > 0:
            level = self.prestige_upgrades["eternal_knowledge"]["level"]
            upgrade_info = PRESTIGE_UPGRADES["eternal_knowledge"]
            knowledge_retention = upgrade_info["effect"]["knowledge_retention"] * level
            
            # Retain ancient knowledge
            retained_knowledge = self.resources.get("ancient_knowledge", 0) * knowledge_retention
        
        # Reset game state
        self.__init__()
        
        # Restore persistent values
        self.prestige_count = old_prestige_count + 1
        self.prestige_points += points_earned
        self.total_prestige_points = old_total_prestige_points + points_earned
        self.prestige_upgrades = old_prestige_upgrades
        self.permanent_multipliers = old_permanent_multipliers
        self.achievements = old_achievements
        self.total_play_time = old_total_play_time
        
        # Apply retained resources
        for resource, amount in retained_resources.items():
            self.resources[resource] = amount
        
        self.resources["ancient_knowledge"] = retained_knowledge
        
        # Apply starting gold bonus from prestige upgrades
        if "faster_start" in self.prestige_upgrades and self.prestige_upgrades["faster_start"]["level"] > 0:
            level = self.prestige_upgrades["faster_start"]["level"]
            upgrade_info = PRESTIGE_UPGRADES["faster_start"]
            starting_gold = upgrade_info["effect"]["starting_gold"] * (upgrade_info["effect_scaling"] ** (level - 1))
            self.resources["gold"] += starting_gold
        
        # Update prestige achievements
        self.check_prestige_achievements()
        
        self.add_notification(f"Prestige complete! Earned {points_earned} prestige points.")
        return True
    
    def calculate_prestige_points(self):
        """Calculate prestige points that would be earned from current progress"""
        # Base calculation on total earnings
        if self.total_earnings < PRESTIGE_REQUIREMENT_BASE:
            return 0
        
        # Calculate points based on a logarithmic scale
        points = int(1 + (self.total_earnings / PRESTIGE_REQUIREMENT_BASE) ** 0.5)
        
        # Apply prestige point multiplier from achievements
        multiplier = 1.0
        for milestone in ACHIEVEMENTS["prestige_milestones"]:
            if "id" in milestone and milestone["id"] in self.achievements["prestige_milestones"] \
               and self.achievements["prestige_milestones"][milestone["id"]]:
                reward = milestone["reward"]
                if "prestige_point_multiplier" in reward:
                    multiplier *= reward["prestige_point_multiplier"]
                if "prestige_point_bonus" in reward:
                    points += reward["prestige_point_bonus"]
        
        return int(points * multiplier)
    
    # Race ability methods
    def check_race_ability_unlocks(self):
        """Check if any race abilities can be unlocked"""
        for race_id, race_data in self.races.items():
            if race_data["unlocked"] and race_data["count"] > 0:
                race_info = RACES[race_id]
                
                # Skip if race has no special abilities
                if "special_abilities" not in race_info:
                    continue
                    
                # Initialize abilities dict if not present
                if "abilities" not in race_data:
                    race_data["abilities"] = {}
                    for ability_id in race_info["special_abilities"]:
                        race_data["abilities"][ability_id] = {
                            "unlocked": False,
                            "active": False
                        }
                    
                for ability_id, ability_info in race_info["special_abilities"].items():
                    # Ensure ability exists in race data
                    if ability_id not in race_data["abilities"]:
                        race_data["abilities"][ability_id] = {
                            "unlocked": False,
                            "active": False
                        }
                        
                    # Skip if already unlocked
                    if race_data["abilities"][ability_id]["unlocked"]:
                        continue
                        
                    # Check requirements
                    req = ability_info["unlock_requirements"]
                    
                    # Check race level requirement
                    if race_data["level"] < req["race_level"]:
                        continue
                        
                    # Check prestige level requirement
                    if self.prestige_count < req["prestige_level"]:
                        continue
                        
                    # Check resource requirements
                    can_afford = True
                    for resource, amount in req["resources"].items():
                        if self.resources.get(resource, 0) < amount:
                            can_afford = False
                            break
                            
                    if not can_afford:
                        continue
                        
                    # All requirements met, unlock the ability
                    race_data["abilities"][ability_id]["unlocked"] = True
                    
                    # Spend the required resources
                    for resource, amount in req["resources"].items():
                        self.resources[resource] -= amount
                    
                    self.add_notification(f"New race ability unlocked: {race_info['name']} - {ability_info['name']}!")
    
    def activate_race_ability(self, race_id, ability_id):
        """Activate a race ability"""
        if race_id not in self.races:
            return False
            
        race_data = self.races[race_id]
        
        # Check if ability exists and is unlocked
        if "abilities" not in race_data or ability_id not in race_data["abilities"]:
            return False
            
        ability_data = race_data["abilities"][ability_id]
        if not ability_data["unlocked"]:
            return False
            
        # Toggle ability active state
        ability_data["active"] = not ability_data["active"]
        
        # Notify player
        race_info = RACES[race_id]
        ability_info = race_info["special_abilities"][ability_id]
        status = "activated" if ability_data["active"] else "deactivated"
        self.add_notification(f"{race_info['name']} ability {ability_info['name']} {status}!")
        
        return True
    
    def get_race_ability_multiplier(self, resource):
        """Get the multiplier for a resource from race abilities"""
        multiplier = 1.0
        
        for race_id, race_data in self.races.items():
            if not race_data["unlocked"] or race_data["count"] <= 0:
                continue
                
            race_info = RACES[race_id]
            if "special_abilities" not in race_info or "abilities" not in race_data:
                continue
                
            for ability_id, ability_data in race_data["abilities"].items():
                if not ability_data["unlocked"] or not ability_data["active"]:
                    continue
                    
                ability_info = race_info["special_abilities"][ability_id]
                effects = ability_info["effects"]
                
                # Apply specific resource multiplier
                if f"{resource}_multiplier" in effects:
                    multiplier *= effects[f"{resource}_multiplier"]
                
                # Apply all resources multiplier
                if "all_resources_multiplier" in effects:
                    multiplier *= effects["all_resources_multiplier"]
                    
                # Apply building efficiency if applicable
                if "building_efficiency" in effects:
                    # This affects resources produced by buildings
                    for building_id, building_data in self.buildings.items():
                        if building_data["count"] > 0 and "resource_production" in BUILDINGS[building_id]:
                            if resource in BUILDINGS[building_id]["resource_production"]:
                                multiplier *= effects["building_efficiency"]
                                break
        
        return multiplier
    
    def get_race_specific_ability_bonus(self, race_id, resource):
        """Get race-specific ability bonus for a resource"""
        bonus = 1.0
        
        if race_id not in self.races or not self.races[race_id]["unlocked"]:
            return bonus
            
        race_data = self.races[race_id]
        race_info = RACES[race_id]
        
        if "special_abilities" not in race_info or "abilities" not in race_data:
            return bonus
            
        for ability_id, ability_data in race_data["abilities"].items():
            if not ability_data["unlocked"] or not ability_data["active"]:
                continue
                
            ability_info = race_info["special_abilities"][ability_id]
            effects = ability_info["effects"]
            
            # Apply per-unit bonus if applicable
            if "per_unit_bonus" in effects:
                bonus += effects["per_unit_bonus"] * race_data["count"]
                
            # Apply gold storage bonus for dragons
            if "gold_storage_bonus" in effects and resource == "gold":
                bonus += (self.resources["gold"] / 1000) * effects["gold_storage_bonus"]
        
        return bonus
    
    def get_passive_generation_rate(self, resource):
        """Get passive generation rate for a resource from race abilities"""
        rate = 0.0
        
        for race_id, race_data in self.races.items():
            if not race_data["unlocked"] or race_data["count"] <= 0:
                continue
                
            race_info = RACES[race_id]
            if "special_abilities" not in race_info or "abilities" not in race_data:
                continue
                
            for ability_id, ability_data in race_data["abilities"].items():
                if not ability_data["unlocked"] or not ability_data["active"]:
                    continue
                    
                ability_info = race_info["special_abilities"][ability_id]
                effects = ability_info["effects"]
                
                # Apply passive generation if applicable
                if "passive_generation" in effects:
                    # Base passive generation on player level
                    rate += effects["passive_generation"] * self.player_level
        
        return rate
    
    def get_time_based_modifier(self, resource):
        """Get time-based modifier for resource generation"""
        modifier = 1.0
        
        for race_id, race_data in self.races.items():
            if not race_data["unlocked"] or race_data["count"] <= 0:
                continue
                
            race_info = RACES[race_id]
            if "special_abilities" not in race_info or "abilities" not in race_data:
                continue
                
            for ability_id, ability_data in race_data["abilities"].items():
                if not ability_data["unlocked"] or not ability_data["active"]:
                    continue
                    
                ability_info = race_info["special_abilities"][ability_id]
                effects = ability_info["effects"]
                
                # Apply timed production bonus if applicable
                if "timed_production_bonus" in effects:
                    # Check if we're in an alignment period (every 5 minutes)
                    current_time = int(time.time())
                    alignment_duration = effects.get("alignment_duration", 300)  # Default 5 minutes
                    if (current_time % 3600) < alignment_duration:  # First 5 minutes of each hour
                        modifier *= effects["timed_production_bonus"]
        
        return modifier
    
    def check_production_doubling_chance(self):
        """Check if production should be doubled based on race abilities"""
        for race_id, race_data in self.races.items():
            if not race_data["unlocked"] or race_data["count"] <= 0:
                continue
                
            race_info = RACES[race_id]
            if "special_abilities" not in race_info or "abilities" not in race_data:
                continue
                
            for ability_id, ability_data in race_data["abilities"].items():
                if not ability_data["unlocked"] or not ability_data["active"]:
                    continue
                    
                ability_info = race_info["special_abilities"][ability_id]
                effects = ability_info["effects"]
                
                # Check for production doubling chance
                if "production_doubling_chance" in effects:
                    if random.random() < effects["production_doubling_chance"]:
                        return True
        
        return False
    
    def apply_special_resource_generation(self, elapsed_time):
        """Apply special resource generation from race abilities"""
        # Handle random resource generation
        for race_id, race_data in self.races.items():
            if not race_data["unlocked"] or race_data["count"] <= 0:
                continue
                
            race_info = RACES[race_id]
            if "special_abilities" not in race_info or "abilities" not in race_data:
                continue
                
            for ability_id, ability_data in race_data["abilities"].items():
                if not ability_data["unlocked"] or not ability_data["active"]:
                    continue
                    
                ability_info = race_info["special_abilities"][ability_id]
                effects = ability_info["effects"]
                
                # Random resource generation (Fae Glamour)
                if "random_resource_generation" in effects:
                    chance = effects["random_resource_generation"] * elapsed_time
                    if random.random() < chance:
                        # Pick a random resource
                        resource = random.choice([r for r in RESOURCE_TYPES if r != "prestige_points"])
                        # Generate an amount based on player level
                        amount = self.player_level * 10 * (1 + self.prestige_count * 0.5)
                        self.resources[resource] += amount
                        self.add_notification(f"Fae glamour generated {amount:.0f} {resource}!")
                
                # Resource conversion (Goblin Scavenger Economy)
                if "resource_conversion" in effects:
                    # Find highest producing resource
                    max_rate = 0
                    max_resource = None
                    for resource in RESOURCE_TYPES:
                        if resource == "prestige_points":
                            continue
                        rate = self.calculate_resource_generation_rate(resource)
                        if rate > max_rate:
                            max_rate = rate
                            max_resource = resource
                    
                    if max_resource and max_rate > 0:
                        conversion_rate = effects["resource_conversion"] * elapsed_time
                        for resource in RESOURCE_TYPES:
                            if resource == "prestige_points" or resource == max_resource:
                                continue
                            amount = max_rate * conversion_rate
                            self.resources[resource] += amount
                
                # Resource transmutation (Dragon Fire)
                if "resource_transmutation" in effects and hasattr(self, "transmutation_source") and hasattr(self, "transmutation_target"):
                    source = self.transmutation_source
                    target = self.transmutation_target
                    if source in RESOURCE_TYPES and target in RESOURCE_TYPES and source != target:
                        # Convert some of source to target at the specified efficiency
                        amount = min(self.resources[source] * 0.01 * elapsed_time, self.resources[source])  # Convert up to 1% per second
                        if amount > 0:
                            self.resources[source] -= amount
                            self.resources[target] += amount * effects["resource_transmutation"]
                
                # Crystal generation from stone (Deepling Pressure Manipulation)
                if "stone_to_crystal_conversion" in effects:
                    stone_produced = self.calculate_resource_generation_rate("stone") * elapsed_time
                    if stone_produced > 0:
                        crystal_amount = stone_produced * effects["stone_to_crystal_conversion"]
                        self.resources["crystal"] += crystal_amount
                
                # Parallel production (Void Walker Dimensional Phasing)
                if "parallel_production" in effects:
                    for resource in RESOURCE_TYPES:
                        if resource == "prestige_points":
                            continue
                        rate = self.calculate_resource_generation_rate(resource)
                        amount = rate * elapsed_time * effects["parallel_production"]
                        self.resources[resource] += amount
    
    def generate_passive_prestige_points(self, elapsed_time):
        """Generate passive prestige points from race abilities"""
        for race_id, race_data in self.races.items():
            if not race_data["unlocked"] or race_data["count"] <= 0:
                continue
                
            race_info = RACES[race_id]
            if "special_abilities" not in race_info or "abilities" not in race_data:
                continue
                
            for ability_id, ability_data in race_data["abilities"].items():
                if not ability_data["unlocked"] or not ability_data["active"]:
                    continue
                    
                ability_info = race_info["special_abilities"][ability_id]
                effects = ability_info["effects"]
                
                # Passive prestige generation (Celestial Cosmic Manipulation)
                if "passive_prestige_generation" in effects:
                    # Generate prestige points based on current total earnings
                    points = self.total_earnings * effects["passive_prestige_generation"] * elapsed_time
                    self.resources["prestige_points"] += points
                    self.total_prestige_points += points
    
    def add_notification(self, message, details=None, notification_type="info"):
        """Add a notification message with optional details and type
        
        Args:
            message (str): The short notification message to display
            details (str, optional): Detailed information to show when clicked
            notification_type (str, optional): Type of notification (info, achievement, unlock, etc.)
        """
        # Create notification with more information
        notification = {
            "text": message,  # Use 'text' key for consistency with UI
            "message": message,  # Keep 'message' for backward compatibility
            "time": pygame.time.get_ticks(),  # Use pygame ticks for consistency
            "type": notification_type,
            "details": details or message,  # If no details provided, use the message
            "id": len(self.notifications) + 1  # Unique identifier
        }
        
        self.notifications.append(notification)
        
        # Limit the number of notifications to prevent memory issues
        if len(self.notifications) > 20:
            self.notifications = self.notifications[-20:]
    
    def get_notifications(self, clear=False):
        """Get all notifications and optionally clear them"""
        notifications = self.notifications.copy()
        if clear:
            self.notifications = []
        return notifications
    
    # Save and load functionality
    def save_game(self, filename="save.json", compressed=True):
        """Save game state to a file
        
        Args:
            filename (str): Path to save file
            compressed (bool): Whether to use compression
        
        Returns:
            bool: True if save was successful, False otherwise
        """
        save_data = {
            "resources": self.resources,
            "races": self.races,
            "buildings": self.buildings,
            "research": self.research,
            "prestige_upgrades": self.prestige_upgrades,
            "achievements": self.achievements,
            "player_level": self.player_level,
            "total_earnings": self.total_earnings,
            "prestige_count": self.prestige_count,
            "prestige_points": self.prestige_points,
            "total_prestige_points": self.total_prestige_points,
            "permanent_multipliers": self.permanent_multipliers,
            "total_play_time": self.total_play_time,
            "time_warp_active": self.time_warp_active,
            "time_warp_end_time": self.time_warp_end_time,
            "time_warp_cooldown_end": self.time_warp_cooldown_end,
            "save_time": time.time(),
            "version": "1.0.0"  # Add version for future compatibility
        }
        
        try:
            save_dir = os.path.dirname(filename)
            if save_dir and not os.path.exists(save_dir):
                os.makedirs(save_dir)
            
            # Determine if we should use compression based on file extension
            use_compression = compressed or filename.endswith(".zsave")
            
            if use_compression:
                # Convert to JSON string, compress, and write to binary file
                json_str = json.dumps(save_data)
                compressed_data = zlib.compress(json_str.encode('utf-8'), level=9)  # Maximum compression
                
                # If filename doesn't have .zsave extension and compression is requested, add it
                if not filename.endswith(".zsave"):
                    filename = filename.replace(".json", ".zsave")
                
                with open(filename, 'wb') as f:
                    f.write(compressed_data)
            else:
                # Standard JSON save
                with open(filename, 'w') as f:
                    json.dump(save_data, f)
                    
            self.last_save_time = time.time()
            return True
        except Exception as e:
            print(f"Error saving game: {e}")
            return False
    
    def export_save_string(self):
        """Export the current game state as a base64 encoded string
        
        Returns:
            str: Base64 encoded save string
        """
        try:
            save_data = {
                "resources": self.resources,
                "races": self.races,
                "buildings": self.buildings,
                "research": self.research,
                "prestige_upgrades": self.prestige_upgrades,
                "achievements": self.achievements,
                "player_level": self.player_level,
                "total_earnings": self.total_earnings,
                "prestige_count": self.prestige_count,
                "prestige_points": self.prestige_points,
                "total_prestige_points": self.total_prestige_points,
                "permanent_multipliers": self.permanent_multipliers,
                "total_play_time": self.total_play_time,
                "time_warp_active": self.time_warp_active,
                "time_warp_end_time": self.time_warp_end_time,
                "time_warp_cooldown_end": self.time_warp_cooldown_end,
                "save_time": time.time(),
                "version": "1.0.0"
            }
            
            # Convert to JSON, compress, and encode to base64
            json_str = json.dumps(save_data)
            compressed_data = zlib.compress(json_str.encode('utf-8'), level=9)
            save_string = base64.b64encode(compressed_data).decode('utf-8')
            
            return save_string
        except Exception as e:
            print(f"Error exporting save string: {e}")
            return None
    
    def import_save_string(self, save_string):
        """Import a game state from a base64 encoded string
        
        Args:
            save_string (str): Base64 encoded save string
            
        Returns:
            bool: True if import was successful, False otherwise
        """
        try:
            # Decode base64, decompress, and parse JSON
            compressed_data = base64.b64decode(save_string)
            json_str = zlib.decompress(compressed_data).decode('utf-8')
            save_data = json.loads(json_str)
            
            # Apply the save data
            self._apply_save_data(save_data)
            
            self.add_notification("Save imported successfully!")
            return True
        except Exception as e:
            print(f"Error importing save string: {e}")
            self.add_notification("Failed to import save. Invalid save string.")
            return False
    
    def load_game(self, filename="save.json"):
        """Load game state from a file
        
        Args:
            filename (str): Path to save file
            
        Returns:
            bool: True if load was successful, False otherwise
        """
        try:
            if not os.path.exists(filename):
                # Try alternative extensions
                alt_filename = filename.replace(".json", ".zsave")
                if not os.path.exists(alt_filename):
                    return False
                filename = alt_filename
            
            # Determine file type based on extension
            if filename.endswith(".zsave"):
                # Compressed binary file
                with open(filename, 'rb') as f:
                    compressed_data = f.read()
                json_str = zlib.decompress(compressed_data).decode('utf-8')
                save_data = json.loads(json_str)
            else:
                # Standard JSON file
                with open(filename, 'r') as f:
                    save_data = json.load(f)
            
            # Apply the save data
            self._apply_save_data(save_data)
            
            return True
        except Exception as e:
            print(f"Error loading game: {e}")
            return False
    
    def _apply_save_data(self, save_data):
        """Apply save data to the current game state and calculate offline progress
        
        Args:
            save_data (dict): Save data to apply
        """
        # Load basic data
        self.resources = save_data.get("resources", self.resources)
        self.races = save_data.get("races", self.races)
        
        # Ensure race skills tracking exists for all races
        for race_id, race_data in self.races.items():
            if "skills" not in race_data:
                race_data["skills"] = {resource: 0 for resource in RESOURCE_TYPES}
        
        self.buildings = save_data.get("buildings", self.buildings)
        self.research = save_data.get("research", self.research)
        self.prestige_upgrades = save_data.get("prestige_upgrades", self.prestige_upgrades)
        self.achievements = save_data.get("achievements", self.achievements)
        
        # Initialize race_skill_milestones if not present
        if "race_skill_milestones" not in self.achievements:
            self.achievements["race_skill_milestones"] = {milestone["id"]: False for milestone in ACHIEVEMENTS["race_skill_milestones"]}
        
        self.player_level = save_data.get("player_level", self.player_level)
        self.total_earnings = save_data.get("total_earnings", self.total_earnings)
        self.prestige_count = save_data.get("prestige_count", self.prestige_count)
        self.prestige_points = save_data.get("prestige_points", self.prestige_points)
        self.total_prestige_points = save_data.get("total_prestige_points", self.total_prestige_points)
        self.permanent_multipliers = save_data.get("permanent_multipliers", self.permanent_multipliers)
        self.total_play_time = save_data.get("total_play_time", self.total_play_time)
        self.time_warp_active = save_data.get("time_warp_active", self.time_warp_active)
        self.time_warp_end_time = save_data.get("time_warp_end_time", self.time_warp_end_time)
        self.time_warp_cooldown_end = save_data.get("time_warp_cooldown_end", self.time_warp_cooldown_end)
        
        # Calculate offline progress
        last_save_time = save_data.get("save_time", time.time())
        current_time = time.time()
        offline_time = current_time - last_save_time
        
        if offline_time > 0:
            # Check if offline progress is enabled through prestige upgrades
            offline_rate = 0.0
            if "automatic_production" in self.prestige_upgrades and self.prestige_upgrades["automatic_production"]["level"] > 0:
                level = self.prestige_upgrades["automatic_production"]["level"]
                upgrade_info = PRESTIGE_UPGRADES["automatic_production"]
                offline_rate = upgrade_info["effect"]["offline_progress"] * level
            else:
                # Default offline progress rate if no upgrade
                offline_rate = OFFLINE_PROGRESS_RATE
            
            # Apply offline progress
            if offline_rate > 0:
                self.generate_resources(offline_time * offline_rate)
                # Format time in a more readable way
                if offline_time < 60:
                    time_str = f"{int(offline_time)} seconds"
                elif offline_time < 3600:
                    time_str = f"{int(offline_time / 60)} minutes"
                else:
                    hours = int(offline_time / 3600)
                    minutes = int((offline_time % 3600) / 60)
                    time_str = f"{hours} hours, {minutes} minutes"
                
                self.add_notification(f"Welcome back! You were away for {time_str} and earned resources at {int(offline_rate * 100)}% efficiency.")
    
    def calculate_max_affordable(self, cost):
        """Calculate the maximum number of items that can be bought with current resources"""
        if not cost:
            return 0
            
        # Get the limiting resource (the one that will run out first)
        limiting_resource = None
        max_count = float('inf')
        
        for resource, amount in cost.items():
            if resource in self.resources:
                current = self.resources[resource]
                if current < amount:
                    count = current // amount
                    if count < max_count:
                        max_count = count
                        limiting_resource = resource
        
        return max_count if max_count != float('inf') else 0
        
    def get_race_upgrade_benefits(self, race_id):
        """Calculate the benefits of upgrading a race to show in tooltip"""
        if race_id not in self.races or not self.races[race_id]["unlocked"]:
            return {}
            
        race_info = RACES[race_id]
        current_level = self.races[race_id]["level"]
        next_level = current_level + 1
        
        benefits = {}
        
        # Calculate resource bonuses improvement
        if "resource_bonuses" in race_info:
            for resource, base_bonus in race_info["resource_bonuses"].items():
                # Current bonus (10% per level)
                current_bonus = base_bonus * (1 + (current_level - 1) * 0.1)
                # Next level bonus
                next_bonus = base_bonus * (1 + (next_level - 1) * 0.1)
                # Improvement
                improvement = next_bonus - current_bonus
                benefits[resource] = f"+{improvement:.2f}x"
        
        # Check for special ability unlocks at specific levels
        if "special_abilities" in race_info:
            for ability_id, ability_info in race_info["special_abilities"].items():
                unlock_requirements = ability_info.get("unlock_requirements", {})
                required_level = unlock_requirements.get("race_level", 0)
                
                # If the next level will unlock this ability
                if required_level > current_level and required_level <= next_level:
                    benefits["ability"] = f"Unlocks progress toward {ability_info['name']}"
        
        return benefits
        
    def get_production_multiplier(self, resource):
        """Get the total production multiplier for a specific resource"""
        # This combines various multipliers from different game systems
        multiplier = 1.0
        
        # Apply global multiplier (includes race bonuses, research, etc.)
        global_multiplier = self.calculate_global_multiplier(resource)
        multiplier *= global_multiplier
        
        # Apply building-specific multipliers if needed
        # (This is a placeholder - expand as needed for your game mechanics)
        
        return multiplier
